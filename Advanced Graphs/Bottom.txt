/*************
BOTTOM

We will use the following (standard) definitions from graph theory. Let V be a non-empty and finite set, its elements being called vertices (or nodes). Let E be a subset of the Cartesian product V×V, its elements being called edges. Then G=(V,E) is called a directed graph.
Let n be a positive integer, and let p=(e1,…,en) be a sequence of length n of edges ei∈E such that ei=(vi,vi+1)for a sequence of vertices (v1,…,vn+1). Then p is called a path from vertex v1 to vertex vn+1 in G and we say that vn+1 is reachable from v1, writing (v1→vn+1).
Here are some new definitions. A node v in a graph G=(V,E) is called a sink, if for every node w in G that is reachable from v, v is also reachable from w. The bottom of a graph is the subset of all nodes that are sinks, i.e., bottom(G)={v∈V∣∀w∈V:(v→w)⇒(w→v)}. You have to calculate the bottom of certain graphs.
Input Format:
First line of input will contain T(number of test case), each test case follows as.
First line will contain two space-separated integers N and M denoting the number of vertex and edges respectively.
Next M line will contain two space separated integers a, b denoting an edge from a to b.
Output Format:
For each test case output the bottom of the specified graph on a single line. 
Constraints:
1 <= T <= 50
1 <= N, M <= 10^5
Sample Input:
1
3 6
3 1
2 3
3 2
1 2
1 3
2 1
Sample Output:
1 2 3 
************/

#include<bits/stdc++.h>
using namespace std;


void dfs(vector<int>* edges, int start, unordered_set<int> &visited, stack<int> &finishStack) {
	visited.insert(start);
	for (int i = 0; i < edges[start].size(); i++) {
		int adjacent = edges[start][i];
		if (visited.count(adjacent) == 0) {
			dfs(edges, adjacent, visited, finishStack);
		}
	}
	finishStack.push(start);
}

void dfs2(vector<int>* edges, int start, unordered_set<int>* component, unordered_set<int> & visited) {
	visited.insert(start);
	component->insert(start);
	for (int i = 0; i < edges[start].size(); i++) {
		int adjacent = edges[start][i];
		if (visited.count(adjacent) == 0) {
			dfs2(edges, adjacent, component, visited);
		}
	}
}

unordered_set<unordered_set<int>*>* getSCC(vector<int>* edges, vector<int>* edgesT, int n) {
	unordered_set<int> visited;
	stack<int> finishedVertices;
	for (int i = 0; i < n; i++) {
		if (visited.count(i) == 0) {
			dfs(edges, i, visited, finishedVertices);
		}
	}
	unordered_set<unordered_set<int>*>* output = new unordered_set<unordered_set<int>*>();
	visited.clear();
	while (finishedVertices.size() != 0) {
		int element = finishedVertices.top();
		finishedVertices.pop();
		if (visited.count(element) != 0) {
			continue;
		}
		unordered_set<int>* component = new unordered_set<int>();
		dfs2(edgesT, element, component, visited);
		output->insert(component);
	}
	return output;
}

void print_component(unordered_set<int>* component){
    unordered_set<int> :: iterator itr = component->begin();
    while(itr != component->end()){
        cout << *itr + 1 << " ";
    }
}

void __bottom(vector<int>* edges, vector<int>* edges_transpose, int n){
    
    unordered_set<unordered_set<int>*>* components = getSCC(edges, edges_transpose, n);
    unordered_set<unordered_set<int>*> :: iterator itr1 = components->begin();
    while(itr1 != components->end()){
        unordered_set<int>* component = *itr1;
        unordered_set<int> :: iterator itr2 = component->begin();
        bool isBottom = true;
        while(itr2 != component->end()){
            if(edges[*itr2].size() != 0){
                isBottom = false;
                break;
            }
        }
        if(isBottom){
           cout<<1;// print_component(component);
        }
    }
    //free space
}


int main(){
    
    int t;
    cin >> t;
    while(t--){
        int n, m; //denoting the number of vertex and edges respectively
        cin >> n >> m;
        vector<int>* edges = new vector<int>[n]();
        vector<int>* edges_transpose = new vector<int>[n]();
        while(m--){
            int a, b; //denoting the number of vertex and edges respectively
            cin >> a >> b;
            edges[a-1].push_back(b-1);
            edges_transpose[b-1].push_back(a-1);
        }
        
        __bottom(edges, edges_transpose, n);
        
        //free space
        // delete[] edges;
    }
    return 0;
}
